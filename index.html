<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let currentUser = "";
    let currentLvl = 1;
    let grid = [];
    let catPath = [];
    let TILE_SIZE = 60;
    const TOTAL_LEVELS = 100;
    const ALL_LEVELS = [];

    // --- æ ¸å¿ƒä¿®æ­£ï¼šDFS å®Œç¾è·¯å¾‘ç”Ÿæˆå™¨ ---
    // é€™èƒ½ä¿è­‰åœ°åœ–æ˜¯å¾èµ·é»å‡ºç™¼ï¼Œä¸€ç­†ç•«å¡«æ»¿æ‰€æœ‰ç©ºæ ¼ï¼Œçµ•å°ä¸æœƒæœ‰æ­»è·¯ã€‚
    function generatePerfectLevel(lvl) {
        const size = Math.min(4 + Math.floor(lvl / 15), 9); 
        let map = Array.from({ length: size }, () => Array(size).fill(1)); // 1æ˜¯ç‰†å£
        
        let path = [];
        let curX = Math.floor(Math.random() * size);
        let curY = Math.floor(Math.random() * size);
        
        path.push({x: curX, y: curY});
        map[curY][curX] = 0; // æŒ–ç©º
        
        // å˜—è©¦å¡«æ»¿åœ°åœ–çš„ 70%~90% ç©ºé–“ï¼Œç¢ºä¿æŒ‘æˆ°æ€§
        const targetEmpty = Math.floor(size * size * 0.8);
        let attempts = 0;

        while(path.length < targetEmpty && attempts < 500) {
            let last = path[path.length - 1];
            let dirs = [[0,1],[0,-1],[1,0],[-1,0]].sort(() => Math.random() - 0.5);
            let found = false;

            for(let d of dirs) {
                let nX = last.x + d[0], nY = last.y + d[1];
                if(nX>=0 && nX<size && nY>=0 && nY<size && map[nY][nX] === 1) {
                    map[nY][nX] = 0;
                    path.push({x: nX, y: nY});
                    found = true;
                    break;
                }
            }
            if(!found) break; // å¦‚æœç„¡è·¯å¯èµ°å‰‡åœæ­¢ï¼Œé€™æ¢è·¯å¾‘å°±æ˜¯å”¯ä¸€è§£
            attempts++;
        }

        // èµ·é»è¨­åœ¨è·¯å¾‘çš„æœ€é–‹é ­
        const start = path[0];
        map[start.y][start.x] = 2; 

        // ä¸»é¡Œé‚è¼¯
        const themes = [
            { bg: "#f7f1e3", wall: "ğŸ“¦", skin: "ğŸ±" },
            { bg: "#d1ccc0", wall: "ğŸ§±", skin: "ğŸ±" },
            { bg: "#ffb8b8", wall: "ğŸŒ¸", skin: "ğŸ¦Š" },
            { bg: "#706fd3", wall: "ğŸ’", skin: "ğŸ²" }
        ];
        
        return {
            map: map,
            theme: themes[Math.floor((lvl-1)/25) % themes.length]
        };
    }

    function generate100Levels() {
        for (let i = 1; i <= TOTAL_LEVELS; i++) {
            ALL_LEVELS.push(generatePerfectLevel(i));
        }
    }

    // --- UI èˆ‡ å­˜æª”é‚è¼¯ (ç¶­æŒä¸è®Š) ---
    function userLogin() {
        const name = document.getElementById('username-input').value.trim();
        if(!name) return alert("è«‹è¼¸å…¥åå­—ï¼");
        currentUser = name;
        const savedData = JSON.parse(localStorage.getItem('longcat_final_v5_' + name)) || { lvl: 1 };
        currentLvl = savedData.lvl;
        document.getElementById('login-modal').style.display = 'none';
        document.getElementById('display-name').innerText = name + " çš„å†’éšª";
        initLevel();
    }

    function initLevel() {
        const data = ALL_LEVELS[currentLvl - 1];
        grid = data.map.map(row => [...row]);
        catPath = [];

        document.body.style.backgroundColor = data.theme.bg;

        for(let r=0; r<grid.length; r++) {
            for(let c=0; c<grid[0].length; c++) {
                if(grid[r][c] === 2) {
                    catPath.push({x: c, y: r});
                    grid[r][c] = 3; // æ¨™è¨˜ç‚ºè²“èº«é«”
                }
            }
        }

        TILE_SIZE = Math.min(60, (window.innerHeight * 0.6) / grid.length);
        canvas.width = grid[0].length * TILE_SIZE;
        canvas.height = grid.length * TILE_SIZE;
        document.getElementById('lvl-num').innerText = currentLvl;
        draw();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const data = ALL_LEVELS[currentLvl - 1];

        for(let r=0; r<grid.length; r++) {
            for(let c=0; c<grid[0].length; c++) {
                ctx.strokeStyle = "rgba(0,0,0,0.05)";
                ctx.strokeRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                if(grid[r][c] === 1) {
                    ctx.font = (TILE_SIZE*0.7) + "px Arial";
                    ctx.fillText(data.theme.wall, c*TILE_SIZE + TILE_SIZE*0.15, r*TILE_SIZE + TILE_SIZE*0.75);
                }
            }
        }

        catPath.forEach((pos, i) => {
            if(i < catPath.length - 1) {
                ctx.font = (TILE_SIZE*0.5) + "px Arial";
                ctx.fillText("ğŸ¾", pos.x*TILE_SIZE + TILE_SIZE*0.25, pos.y*TILE_SIZE + TILE_SIZE*0.7);
            }
        });

        const head = catPath[catPath.length - 1];
        ctx.font = (TILE_SIZE*0.8) + "px Arial";
        ctx.fillText(data.theme.skin, head.x*TILE_SIZE + TILE_SIZE*0.1, head.y*TILE_SIZE + TILE_SIZE*0.8);
    }

    function move(dx, dy) {
        let head = catPath[catPath.length - 1];
        let moved = false;
        while(true) {
            let nX = head.x + dx, nY = head.y + dy;
            if(nY >= 0 && nY < grid.length && nX >= 0 && nX < grid[0].length && grid[nY][nX] === 0) {
                grid[nY][nX] = 3;
                catPath.push({x: nX, y: nY});
                head = {x: nX, y: nY};
                moved = true;
            } else { break; }
        }
        if(moved) { draw(); checkWin(); }
    }

    function checkWin() {
        const hasEmpty = grid.some(row => row.includes(0));
        if(!hasEmpty) {
            setTimeout(() => {
                if(currentLvl >= 100) {
                    alert("ä½ æ˜¯çœŸæ­£çš„é•·é•·è²“å¤§å¸«ï¼100 é—œé”æˆï¼");
                } else {
                    currentLvl++;
                    localStorage.setItem('longcat_final_v5_' + currentUser, JSON.stringify({ lvl: currentLvl }));
                    initLevel();
                }
            }, 200);
        }
    }

    function resetLevel() { initLevel(); }
    function logout() { location.reload(); }

    window.addEventListener('keydown', (e) => {
        if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) e.preventDefault();
        if(e.key === "ArrowUp") move(0, -1);
        if(e.key === "ArrowDown") move(0, 1);
        if(e.key === "ArrowLeft") move(-1, 0);
        if(e.key === "ArrowRight") move(1, 0);
    });

    generate100Levels();
</script>
